module Lec1 where

Id : Type
Id = (x : Type) -> (x -> x)

id : Id
id = \x y . y

idid : Id
idid = id Id id

compose : (A : Type) -> (B : Type) -> (C : Type) ->
  (B -> C) -> (A -> B) -> (A -> C)
compose = \ A B C f g x. (f (g x))

-- some Church encodings: booleans

CBool : Type
CBool = (A : Type) -> A -> A -> A

true : CBool
true = \A x y. x

false : CBool
false = \A x y. y

cond : CBool -> (x : Type) -> x -> x -> x
cond = \b. b

void : Type
void = (x : Type) -> x

unit : Type
unit = (x : Type) -> x -> x

-- need definitional equality for this one

bool' : CBool -> Type
bool' = \b . (B : (b : CBool) -> Type) -> (B true) -> B false -> B b

true' : bool' true
true' = \A x y . x

false' : bool' false
false' = \A x y. y
