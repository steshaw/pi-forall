module NatChurch where

-- Church encoding of natural numbers

nat : Type
nat = (x : Type) -> x -> (x -> x) -> x

z : nat
z = \x zf sf. zf

s : nat -> nat
s = \n. \x zf sf. sf (n x zf sf)

one : nat
one = s z

two : nat
two = s (s z)

plus : nat -> nat -> nat
plus = \x. \y. x nat y s

test0 : plus one one = two
test0 = refl

spec0 : (n : nat) -> plus z n = n
spec0 = \n . refl

spec1 : (n : nat) -> (m : nat) -> plus (s n) m  = s (plus n m)
spec1 = \n m . refl

-- this one is *really* tricky!

pred : nat -> nat
pred = TRUSTME

{-
test_pred : pred two = one
test_pred = refl
-}

-- Since pi-forall allows recursive definitions, we also have Scott encodings
-- of datatypes available. (See http://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding.
-- You can't do this in Coq or Agda because it requires an inconsistent logic).

ScottNat : Type
ScottNat = (x : Type) -> x -> (ScottNat -> x) -> x

scott_z : ScottNat
scott_z = \x z s. z

scott_s : ScottNat -> ScottNat
scott_s = \n. \x z s. s n

scott_one : ScottNat
scott_one = scott_s scott_z

scott_two : ScottNat
scott_two = scott_s scott_one

scott_three : ScottNat
scott_three = scott_s scott_two

-- Write the predecessor function, it is much easier here

scott_pred : ScottNat -> ScottNat
scott_pred = \n. n ScottNat scott_z (\n. n)

scott_pred_test0 : scott_pred scott_z = scott_z
scott_pred_test0 = refl

scott_pred_test1 : scott_pred scott_one = scott_z
scott_pred_test1 = refl

scott_pred_test2 : scott_pred scott_two = scott_one
scott_pred_test2 = refl

-- Now write plus: with Scott encoded nats, note that you need to use recursion.

scott_plus : ScottNat -> ScottNat -> ScottNat
scott_plus = \n m. m ScottNat n (\n. scott_s n)

scott_plus_test_0 : scott_plus scott_one scott_two = scott_three
scott_plus_test_0 = refl
